#!/applications/R/R-3.6.0/bin/Rscript

# Convert samtools pileup file into a haplotype matrix
# for visualisation of recombination over interval

# Usage:
# ./pileup_to_haplotype_load_hapMat.R barcode1_120 60 0.153  

#sample <- "barcode1_120"
#MAPQ <- 60
#cMscale <- 0.153

args <- commandArgs(trailingOnly = T)
sample <- args[1]
MAPQ <- args[2]
cMscale <- as.numeric(args[3])

setwd("/home/ajt200/analysis/nanopore/pollen_typing/")
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggthemes)
library(grid)
library(gridExtra)
library(extrafont)
font_import()
loadfonts()
library(ComplexHeatmap)
library(Cairo)
library(png)
library(Biostrings)
library(parallel)
library(doParallel)
registerDoParallel(cores = detectCores())
print("Currently registered parallel backend name, version and cores")
print(getDoParName())
print(getDoParVersion())
print(getDoParWorkers())

hapMatDir <- "haplotype_matrices/"
system(paste0("[ -d ", hapMatDir, " ] || mkdir ", hapMatDir))
plotDir <- "plots/"
system(paste0("[ -d ", plotDir, " ] || mkdir ", plotDir))
plotDir <- paste0(plotDir, "complete_and_imputed_haplotypes/")
system(paste0("[ -d ", plotDir, " ] || mkdir ", plotDir))

# Load reference and alternate alleles
alleles <- read.table("3a_SNPs_indels_in_Col_and_Ws.tsv",
                      header = T)
# Replace factors with characters
factorColumns <- sapply(alleles, is.factor)
alleles[factorColumns] <- lapply(alleles[factorColumns], as.character)
# Re-specify Ws-4 deletion allele at Chr3:637898 in row 8 of "alleles"
## NOTE: This could be made more or less specific to the known Col allele "ATGTTT" (vs. "AAAAA" in Ws-4)
## to capture sequences lacking either complete or partial matches to "TGTTT"
alleles[8, ]$Ws.4 <- "[.,]-[1-9]T"
# Re-specify Ws-4 alleles at Chr3:638788 in "alleles"
## NOTE: In the following two cases of insertions in Ws-4, the alternate allele specified
## could be made more specific to the known Ws-4 allele "TAT" (vs. "T" in Col) to capture
## sequences containing exact matches to the "AT" insertion in Ws-4
## However, only putative insertions with additional inserted bases (e.g., "ATA") were
## observed in the 5 samples
alleles[20, ]$Ws.4 <- "[.,]\\+[1-9]AT"
# Re-specify Ws-4 alleles at Chr3:639539 in "alleles"
alleles[23, ]$Ws.4 <- "[.,]\\+[1-9]AT"
# The alternate alleles for rows 20 and 23 (Chr3:638788 and 639539) appear not to be
# correctly called using ONT reads, possibly due the limited ability of this technology to generate
# sequences of repeat arrays that represent the true number of repeats in an array
# We observe largely ostensible reference alleles at these markers (e.g., 44163/55803 [79%] and 48451/55803 [87%]),
# which is improbable given that these alignments represent recombinant molecules which
# have the alternate (Ws-4) alleles at the rightmost marker
# (located within the Ws-4 allele-specific primer binding site)
# Therefore, remove rows 20 and 23 (Chr3:638788 and 639539)
alleles <- alleles[c(-20, -23), ]
# Remove rows 8, 9, 10, 11, 12 and 13 (Chr3:637898,637899, 637900, 637901, 637902, and 637903)
# (i.e., remove all info for this indel polymorphism;
# previously used information in row 8 (Chr3:637898) to obtain genotype at this indel polymorphism;
# ATGTTT in Col, AAAAA in Ws-4)
alleles <- alleles[-8:-13, ]
rownames(alleles) <- 1:dim(alleles)[1]

# Load pileup containing per-alignment genotype information,
# as generated by samtools mpileup
#plp <- read.table(paste0("minimap2_TAIR10_",
#                         sample,
#                         "_sorted_primary_MAPQ", MAPQ, ".plp"),
#                  header = F, sep = "\t",
#                  quote = "", comment.char = "",
#                  stringsAsFactors = F)
## Remove rows 20 and 23 (Chr3:638788 and 639539)
## Remove rows 8, 9, 10, 11, 12 and 13 (Chr3:637898,637899, 637900, 637901, 637902, and 637903)
## (i.e., remove all info for this indel polymorphism;
## previously used information in row 8 (Chr3:637898) to obtain genotype at this indel polymorphism;
## ATGTTT in Col, AAAAA in Ws-4)
#plp <- plp[c(-20, -23), ]
#plp <- plp[-8:-13, ]
#rownames(plp) <- 1:dim(plp)[1]
#
## Append the first 3 columns, the alternate allele, and columns
## corresponding to per-alignment file genotype
#plp <- data.frame(plp[ ,1:3],
#                  alleles[ ,4],
#                  plp[ ,seq(from = 5, 
#                            to = dim(plp)[2]-1,
#                            by = 3)])
#colnames(plp) <- c("chr", "pos", "ref", "alt",
#                   seq(1:(dim(plp)[2]-4)))
## Replace factors with characters
#factorColumns <- sapply(plp, is.factor)
#plp[factorColumns] <- lapply(plp[factorColumns], as.character)
#write.table(plp,
#            file = paste0(hapMatDir, sample, "_ONT_pileup_alleles.tsv"),
#            quote = F, sep = "\t",
#            row.names = F, col.names = T)
#plpHap <- plp

## Re-encode haplotypes using genotype naming convention
## to avoid incorrect encoding of adenosine bases
## Col-0 as "AA", Ws-4 as "BB", "*" and all others as "-" 
#for(x in 1:(dim(plpHap)[1])) {
#  for(y in 5:(dim(plpHap)[2])) {
#    print(paste0("Marker ", x, " of ", dim(plpHap)[1],
#                 ": Alignment ", y-4, " of ", dim(plpHap)[2]-4))
#    if( plpHap[x,y] %in% c(".", ",", "^].", "^],", ".$", ",$") ) {
#      plpHap[x,y] <- "AA"
#    } else if( plpHap[x,y] %in% c(plpHap[x,4],
#                                  tolower(plpHap[x,4]),
#                                  paste0("^]", plpHap[x,4]),
#                                  paste0("^]", tolower(plpHap[x,4])),
#                                  paste0(plpHap[x,4], "$"),
#                                  paste0(tolower(plpHap[x,4]), "$")) ) {
#      plpHap[x,y] <- "BB"
#    } else if( grepl(pattern = plpHap[x,4],
#                     x = plpHap[x,y],
#                     ignore.case = T,
#                     perl = T) ) {
#      plpHap[x,y] <- "BB"
#    } else {
#      plpHap[x,y] <- "-"
#    }
#  }
#}
## Convert genotype naming convention into
## haplotype naming convention as we cannot derive
## each allele from single-molecule sequencing
#plpHap[] <- lapply(plpHap, function(x) as.character(gsub("AA", "A", x)))
#plpHap[] <- lapply(plpHap, function(x) as.character(gsub("BB", "B", x)))
#
#write.table(plpHap,
#            file = paste0(hapMatDir, sample, "_ONT_pileup_to_haplotype.tsv"),
#            quote = F, sep = "\t",
#            row.names = F, col.names = T)

plpHap <- read.table(paste0(hapMatDir, sample, "_ONT_pileup_to_haplotype.tsv"),
                     header = T, sep = "\t",
                     stringsAsFactors = F)
colnames(plpHap) <- c("chr", "pos", "ref", "alt",
                      seq(1:(dim(plpHap)[2]-4)))
integerColumns <- sapply(plpHap, is.integer)
plpHap[integerColumns] <- lapply(plpHap[integerColumns], as.character)

# Transpose haplotype matrix for sorting
tplpHap <- data.frame(t(plpHap[,5:dim(plpHap)[2]]))
colnames(tplpHap) <- as.integer(plpHap$pos)

# As the first (leftmost) and last (rightmost) markers are
# within the primer binding sites and may be artificially converted
# into an allele within the allele-specific primer, strip these markers
# (first and last columns) from tplpHap
tplpHap <- tplpHap[,2:(dim(tplpHap)[2]-1)]

# Add column representing haplotypes as character strings
stringHap <- sapply(1:(dim(tplpHap)[1]), function(x) {
  paste0(as.character(as.matrix(tplpHap[x,])), collapse = "")
})
tplpHap <- data.frame(tplpHap,
                      hap = stringHap)
colnames(tplpHap) <- c(as.integer(plpHap$pos[2:(length(plpHap$pos)-1)]),
                       "hap")
# Replace factors with characters
factorColumns <- sapply(tplpHap, is.factor)
tplpHap[factorColumns] <- lapply(tplpHap[factorColumns], as.character)

# Retain only rows that contain both parental haplotypes
tplpHap <- tplpHap[grepl("A", tplpHap$hap) &
                   grepl("B", tplpHap$hap),]


# Load truncated pileup matrix containing variants
plp2 <- read.table(paste0(hapMatDir, sample, "_ONT_pileup_alleles.tsv"),
                   header = T, sep = "\t",
                   stringsAsFactors = F)
colnames(plp2) <- c("chr", "pos", "ref", "alt",
                    seq(1:(dim(plp2)[2]-4)))

# Re-encode haplotypes using genotype naming convention
# to avoid incorrect encoding of adenosine bases;
# Col-0 as "AA", Ws-4 as "BB", etc.
for(x in 1:(dim(plp2)[1])) {
  for(y in 5:(dim(plp2)[2])) {
    print(paste0("Marker ", x, " of ", dim(plp2)[1],
                 ": Alignment ", y-4, " of ", dim(plp2)[2]-4))
    if( plp2[x,y] %in% c(".", ",", "^].", "^],", ".$", ",$") ) {
      plp2[x,y] <- "AA"
    } else if( plp2[x,y] %in% c(plp2[x,4],
                                tolower(plp2[x,4]),
                                paste0("^]", plp2[x,4]),
                                paste0("^]", tolower(plp2[x,4])),
                                paste0(plp2[x,4], "$"),
                                paste0(tolower(plp2[x,4]), "$")) ) {
      plp2[x,y] <- "BB"
    } else if( grepl(pattern = plp2[x,4],
                     x = plp2[x,y],
                     ignore.case = T,
                     perl = T) ) {
      plp2[x,y] <- "BB"
    } else if( plp2[x,y] %in% c("A", "C", "G", "T",
                                "a", "c", "g", "t",
                                "^]A", "^]C", "^]G", "^]T",
                                "^]a", "^]c", "^]g", "^]t",
                                "A$", "C$", "G$", "T$",
                                "a$", "c$", "g$", "t$") ) {
      plp2[x,y] <- "XX"
    } else if( plp2[x,y] %in% c("*", "^]*", "*$") ) {
      plp2[x,y] <- "NN"
    } else {
      plp2[x,y] <- "ID"
    }
  }
}
#write.table(plp2,
#            file = paste0(hapMatDir, sample, "_ONT_pileup_alleles_errors.tsv"),
#            quote = F, sep = "\t",
#            row.names = F, col.names = T)
# Convert genotype naming convention into
# haplotype naming convention as we cannot derive
# each allele from single-molecule sequencing
plp2[] <- lapply(plp2, function(x) as.character(gsub("AA", "A", x)))
plp2[] <- lapply(plp2, function(x) as.character(gsub("BB", "B", x)))
plp2[] <- lapply(plp2, function(x) as.character(gsub("XX", "X", x)))
plp2[] <- lapply(plp2, function(x) as.character(gsub("ID", "I", x)))
plp2[] <- lapply(plp2, function(x) as.character(gsub("NN", "N", x)))
plpHapVar <- plp2
write.table(plpHapVar,
            file = paste0(hapMatDir, sample, "_ONT_pileup_to_haplotype_incl_nonparental.tsv"),
            quote = F, sep = "\t",
            row.names = F, col.names = T)

plpHapVar <- read.table(paste0(hapMatDir, sample, "_ONT_pileup_to_haplotype_incl_nonparental.tsv"),
                        header = T, sep = "\t",
                        stringsAsFactors = F)
colnames(plpHapVar) <- c("chr", "pos", "ref", "alt",
                         seq(1:(dim(plpHapVar)[2]-4)))
integerColumns <- sapply(plpHapVar, is.integer)
plpHapVar[integerColumns] <- lapply(plpHapVar[integerColumns], as.character)

# Transpose haplotype matrix for sorting
tplpHapVar <- data.frame(t(plpHapVar[,5:dim(plpHapVar)[2]]))
colnames(tplpHapVar) <- as.integer(plpHapVar$pos)

# As the first (leftmost) and last (rightmost) markers are
# within the primer binding sites and may be artificially converted
# into an allele within the allele-specific primer, strip these markers
# (first and last columns) from tplpHapVar
tplpHapVar <- tplpHapVar[,2:(dim(tplpHapVar)[2]-1)]

# Add column representing haplotypes as character strings
stringHapVar <- sapply(1:(dim(tplpHapVar)[1]), function(x) {
  paste0(as.character(as.matrix(tplpHapVar[x,])), collapse = "")
})
tplpHapVar <- data.frame(tplpHapVar,
                         hap = stringHapVar)
colnames(tplpHapVar) <- c(as.integer(plpHapVar$pos[2:(length(plpHapVar$pos)-1)]),
                          "hap")
# Replace factors with characters
factorColumns <- sapply(tplpHapVar, is.factor)
tplpHapVar[factorColumns] <- lapply(tplpHapVar[factorColumns], as.character)

# Discard any haplotypes that have the Ws-4 ("B") allele at the leftmost marker
# that is not within the forward primer binding site (Chr3:634,938),
# and any haplotypes that have the Col-0 ("A") allele at the rightmost marker
# that is not within the reverse primer binding site (Chr3:639,370),
# UNLESS these haplotypes start and end with the same parental allele and they have
# at least three intervening markers with the alternate parental allele.
## Many of these apparent noncrossover haplotypes should be rejected due to
## high sequencing error rates at the markers around which noncrossovers ostensibly occur
tplpHapVar_BAAAB_idx <- which(grepl(pattern = "^B\\w*A{1,}\\w*A{1,}\\w*A{1,}\\w*B$",
                                    x = tplpHapVar$hap,
                                    perl = T))
tplpHapVar_ABBBA_idx <- which(grepl(pattern = "^A\\w*B{1,}\\w*B{1,}\\w*B{1,}\\w*A$",
                                    x = tplpHapVar$hap,
                                    perl = T))
tplpHapVar_notStartB_idx <- which(!grepl(pattern = "^B",
                                         x = tplpHapVar$hap))
tplpHapVar_notEndA_idx <- which(!grepl(pattern = "A$",
                                       x = tplpHapVar$hap))
tplpHapVar_notStartB_notEndA_idx <- intersect(tplpHapVar_notStartB_idx,
                                              tplpHapVar_notEndA_idx)
tplpHapVar <- tplpHapVar[c(tplpHapVar_BAAAB_idx,
                           tplpHapVar_ABBBA_idx,
                           tplpHapVar_notStartB_notEndA_idx),]

# Replace each sequencing error (nonparental SNVs, nonparental indels, and missing base calls)
# with a dash to enable potential replacement with parental alleles by imputation
tplpHapPar <- tplpHapVar
tplpHapPar[] <- lapply(tplpHapPar, function(x) as.character(gsub("X", "-", x)))
tplpHapPar[] <- lapply(tplpHapPar, function(x) as.character(gsub("I", "-", x)))
tplpHapPar[] <- lapply(tplpHapPar, function(x) as.character(gsub("N", "-", x)))

# Retain only rows that contain both parental haplotypes
tplpHapPar <- tplpHapPar[grepl("A", tplpHapPar$hap) &
                         grepl("B", tplpHapPar$hap),]


#### YET TO BE DONE
## Extract alignments with complete haplotypes
## Identify haplotypes in the top 5th percentile,
## determine corresponding proportions for these haplotypes,
## and impute missing data for alignments with incomplete haplotypes
## based on these proportions
#tplpHap_complete <- tplpHap[!grepl("-", tplpHap$hap),]
#tplpHap_complete_n <- tplpHap_complete %>%
#  group_by(hap) %>%
#  summarize(n())
#tplpHap_complete_n_quant <- tplpHap_complete_n %>%
#  filter(`n()` > quantile(`n()`, 0.95))
#### YET TO BE DONE


# Apply a haplotype imputation approach which
# is informed by haplotypes at flanking markers
# and, later, by haplotypes within other alignments

# For imputation of missing haplotypes that are not at
# the ends of an alignment, they must be flanked by
# two of the same parental allele, one on each side
# (e.g., for "AAAA-AAA-AAAAA-BB", only the first and second "-",
#  and not the third "-", would be imputed as "A")
# For Col-0 (A) alleles
while( sum(grepl(pattern = "A(-+)A",
                 x = tplpHapPar$hap,
                 perl = T)) > 0 ) {
  for(x in 1:length(tplpHapPar$hap)) {
    if( grepl(pattern = "A(-+)A",
              x = tplpHapPar$hap[x],
              perl = T) ) {
      tplpHapPar$hap[x] <- sub(pattern = "A(-+)A",
                               replacement = paste0("A",
                                                    paste0(rep(x = "A",
                                                               times = attr(regexpr(pattern = "A(-+)A",
                                                                                    text = tplpHapPar$hap[x],
                                                                                    perl = T),
                                                                            'capture.length')[1]),
                                                           collapse = ""),
                                                    "A"),
                               x = tplpHapPar$hap[x],
                               perl = T)
    }
  }
}
# For Ws-4 (B) alleles
while( sum(grepl(pattern = "B(-+)B",
                 x = tplpHapPar$hap,
                 perl = T)) > 0 ) {
  for(x in 1:length(tplpHapPar$hap)) {
    if( grepl(pattern = "B(-+)B",
              x = tplpHapPar$hap[x],
              perl = T) ) {
      tplpHapPar$hap[x] <- sub(pattern = "B(-+)B",
                               replacement = paste0("B",
                                                    paste0(rep(x = "B",
                                                               times = attr(regexpr(pattern = "B(-+)B",
                                                                                    text = tplpHapPar$hap[x],
                                                                                    perl = T),
                                                                            'capture.length')[1]),
                                                           collapse = ""),
                                                    "B"),
                               x = tplpHapPar$hap[x],
                               perl = T)
    }
  }
}

# Impute missing haplotypes at the ends of an alignment based
# on the haplotype at the nearest marker(s)

# As an allele-specific primer on the left binds only Col-0 (A) alleles,
# impute missing haplotypes at the left-hand side (beginning) of alignments
# that have a Col-0 (A) allele at a marker on their right
# (e.g., for "----ABBBBBBBBBA-", only the left-hand "----" and
#  not the right-hand "-" would be imputed as "A")
# For Col-0 (A) alleles
# left-hand side (beginning) of alignments
while( sum(grepl(pattern = "^(-+)A",
                 x = tplpHapPar$hap,
                 perl = T)) > 0 ) {
  for(x in 1:length(tplpHapPar$hap)) {
    if( grepl(pattern = "^(-+)A",
              x = tplpHapPar$hap[x],
              perl = T) ) {
      tplpHapPar$hap[x] <- sub(pattern = "^(-+)A",
                               replacement = paste0(paste0(rep(x = "A",
                                                               times = attr(regexpr(pattern = "^(-+)A",
                                                                                    text = tplpHapPar$hap[x],
                                                                                    perl = T),
                                                                            'capture.length')[1]),
                                                           collapse = ""),
                                                    "A"),
                               x = tplpHapPar$hap[x],
                               perl = T)
    }
  }
}
## right-hand side (end) of alignments
## (to be used for Col-0 (A) alleles ONLY where a Col-0-specific
##  primer binds the right-hand side of the amplicon)
#while( sum(grepl(pattern = "A(-+)$",
#                 x = tplpHapPar$hap,
#                 perl = T)) > 0 ) {
#  for(x in 1:length(tplpHapPar$hap)) {
#    if( grepl(pattern = "A(-+)$",
#              x = tplpHapPar$hap[x],
#              perl = T) ) {
#      tplpHapPar$hap[x] <- sub(pattern = "A(-+)$",
#                            replacement = paste0("A",
#                                                 paste0(rep(x = "A",
#                                                            times = attr(regexpr(pattern = "A(-+)$",
#                                                                                 text = tplpHapPar$hap[x],
#                                                                                 perl = T),
#                                                                         'capture.length')[1]),
#                                                        collapse = "")),
#                            x = tplpHapPar$hap[x],
#                            perl = T)
#    }
#  }
#}

# As an allele-specific primer on the right binds only Ws-4 (B) alleles,
# impute missing haplotypes at the right-hand side (end) of alignments
# that have a Ws-4 (B) allele at a marker on their left
# (e.g., for "-BAAAAAAAAAB----", only the right-hand "----" and
#  not the left-hand "-" would be imputed as "B")
# For Ws-4 (B) alleles
# right-hand side (end) of alignments
while( sum(grepl(pattern = "B(-+)$",
                 x = tplpHapPar$hap,
                 perl = T)) > 0 ) {
  for(x in 1:length(tplpHapPar$hap)) {
    if( grepl(pattern = "B(-+)$",
              x = tplpHapPar$hap[x],
              perl = T) ) {
      tplpHapPar$hap[x] <- sub(pattern = "B(-+)$",
                               replacement = paste0("B",
                                                    paste0(rep(x = "B",
                                                               times = attr(regexpr(pattern = "B(-+)$",
                                                                                    text = tplpHapPar$hap[x],
                                                                                    perl = T),
                                                                            'capture.length')[1]),
                                                           collapse = "")),
                               x = tplpHapPar$hap[x],
                               perl = T)
    }
  }
}
## (to be used for Ws-4 (B) alleles ONLY where a Ws-4-specific
##  primer binds the left-hand side of the amplicon)
## left-hand side (beginning) of alignments
#while( sum(grepl(pattern = "^(-+)B",
#                 x = tplpHapPar$hap,
#                 perl = T)) > 0 ) {
#  for(x in 1:length(tplpHapPar$hap)) {
#    if( grepl(pattern = "^(-+)B",
#              x = tplpHapPar$hap[x],
#              perl = T) ) {
#      tplpHapPar$hap[x] <- sub(pattern = "^(-+)B",
#                            replacement = paste0(paste0(rep(x = "B",
#                                                            times = attr(regexpr(pattern = "^(-+)B",
#                                                                                 text = tplpHapPar$hap[x],
#                                                                                 perl = T),
#                                                                         'capture.length')[1]),
#                                                        collapse = ""),
#                                                 "B"),
#                            x = tplpHapPar$hap[x],
#                            perl = T)
#    }
#  }
#}

# Order by (imputed) haplotypes
tplpHapPar_sort <- tplpHapPar[sort.int(tplpHapPar$hap,
                                       decreasing = T,
                                       index.return=T)$ix,]
# Group by (imputed) haplotypes
tplpHapPar_group_n <- tplpHapPar %>%
  group_by(hap) %>%
  summarize(n())

# Extract the top 1% of haplotypes in terms
# of frequency of occurrence
tplpHapPar_group_n_quant <- tplpHapPar_group_n %>%
  filter(`n()` > quantile(`n()`, 0.99))

tplpHapPar_group_n_v1 <- tplpHapPar_group_n
tplpHapPar_group_n_quant_v1 <- tplpHapPar_group_n_quant

# For those haplotypes in the top 1% which contain "-",
# impute "-" as "A" or "B" proportional to the observed
# frequency of occurrence of the two otherwise matching
# haplotypes
# (e.g., "A-BBBBBBBBBBBBBB" occurs 130 times,
#        "AABBBBBBBBBBBBBB" occurs 550 times,   
#        "ABBBBBBBBBBBBBBB" occurs 2332 times;
#  550 + round( 130 * ( 550 / (550+2332) ) ) = 575 "AABBBBBBBBBBBBBB" occurrences after imputation
#  2332 + round( 130 * ( 2332 / (550+2332) ) ) = 2437 "ABBBBBBBBBBBBBBB" occurrences after imputation
while( sum(grepl(pattern = "-",
                 x = tplpHapPar_group_n_quant$hap,
                 perl = T)) > 0 ) {
  for(x in 1:length(tplpHapPar_group_n_quant$hap)) {
    if( grepl(pattern = "-",
              x = tplpHapPar_group_n_quant$hap[x],
              perl = T) ) {
      impA <- sub(pattern = "(-+)",
                  replacement = paste0(rep(x = "A",
                                           times = attr(regexpr(pattern = "(-+)",
                                                                text = tplpHapPar_group_n_quant$hap[x],
                                                                perl = T),
                                                        'capture.length')[1]),
                                       collapse = ""),
                  x = tplpHapPar_group_n_quant$hap[x],
                  perl = T)
      impB <- sub(pattern = "(-+)",
                  replacement = paste0(rep(x = "B",
                                           times = attr(regexpr(pattern = "(-+)",
                                                                text = tplpHapPar_group_n_quant$hap[x],
                                                                perl = T),
                                                        'capture.length')[1]),
                                       collapse = ""),
                  x = tplpHapPar_group_n_quant$hap[x],
                  perl = T)
      hapNfreq <- tplpHapPar_group_n_quant$`n()`[x]
      hapAfreq <- tplpHapPar_group_n$`n()`[tplpHapPar_group_n$hap %in% impA]
      hapBfreq <- tplpHapPar_group_n$`n()`[tplpHapPar_group_n$hap %in% impB]
      # If impA or impB are not present in tplpHapPar_group_n$hap (unlikely),
      # redefine zero-length integer vector ( integer(0) ) with 0
      if( !length(hapAfreq) ) { hapAfreq <- 0 }
      if( !length(hapBfreq) ) { hapBfreq <- 0 }
      if( hapAfreq + hapBfreq >= 1 ) {
        hapNfreqA <- round( hapNfreq * ( hapAfreq / ( hapAfreq + hapBfreq ) ) )
        hapNfreqB <- round( hapNfreq * ( hapBfreq / ( hapAfreq + hapBfreq ) ) )
        imphapAfreq <- hapAfreq + hapNfreqA
        print(paste0("Augmented haplotype frequency for ",
                     impA, " = ", imphapAfreq))
        imphapBfreq <- hapBfreq + hapNfreqB
        print(paste0("Augmented haplotype frequency for ",
                     impB, " = ", imphapBfreq))
        # Sanity check
        if( ( imphapAfreq + imphapBfreq ) != ( hapNfreq + hapAfreq + hapBfreq ) ) {
          stop(paste0("Augmented haplotype frequencies for ",
                      tplpHapPar_group_n_quant$hap[x],
                      " do not add up to summed frequencies for ",
                      tplpHapPar_group_n_quant$hap[x], " , ",
                      impA, " , and ",
                      impB, " !"))
        }
      } else {
      stop(paste0("Complete versions of haplotype ",
                  tplpHapPar_group_n_quant$hap[x],
                  " are not present in the alignment dataset!"))
      }
      # Replace haplotypes in tplpHapPar$hap matching tplpHapPar_group_n_quant$hap[x]
      # with imputed haplotypes proportional to the observed
      # frequency of occurrence of the two otherwise matching haplotypes
      # which have "A" or "B" at the marker with "-" in tplpHapPar_group_n_quant$hap[x]
      tplpHapPar[tplpHapPar$hap == tplpHapPar_group_n_quant$hap[x],]$hap <- c(rep(x = impA,
                                                                                  times = hapNfreqA),
                                                                              rep(x = impB,
                                                                                  times = hapNfreqB))
    }
  }
  # Group by (imputed) haplotypes
  tplpHapPar_group_n <- tplpHapPar %>%
    group_by(hap) %>%
    summarize(n())
  
  # Extract the top 1% of haplotypes in terms
  # of frequency of occurrence
  tplpHapPar_group_n_quant <- tplpHapPar_group_n %>%
    filter(`n()` > quantile(`n()`, 0.99))
}

# Convert haplotype frequencies into proportions
tplpHapPar_group_n_quant_prop <- tplpHapPar_group_n_quant$`n()` /
                                 (sum(tplpHapPar_group_n_quant$`n()`))

# Get inter-marker distances and midpoints
#### NOTE CHANGE WIDTH DEFINED BY COLUMN NUMBER
midpoints <- NULL
widths <- NULL
for(x in 1:(length(as.integer(colnames(tplpHapPar)[1:(dim(tplpHapPar)[2]-1)]))-1)) {
  midpointx <- as.integer(colnames(tplpHapPar)[x]) +
    round( ( as.integer(colnames(tplpHapPar)[x+1]) -
             as.integer(colnames(tplpHapPar)[x]) ) / 2 )
  midpoints <- c(midpoints, midpointx)
  widthx <- ( as.integer(colnames(tplpHapPar)[x+1]) -
              as.integer(colnames(tplpHapPar)[x]) ) + 1
  widths <- c(widths, widthx)
}
widths <- as.vector(sapply(seq_along(widths), function(x) rep(widths[x], times = 2)))

# Create a matrix of inter-marker recombination intervals, in which
# 1 denotes an "A" to "B" or a "B" to "A" transition, and
# 0 denotes no transition in parental allele from one marker to the next
# Two "1"s or two "0"s are appended to represent two-marker interval
tplpHapPar_quant <- tplpHapPar[tplpHapPar$hap %in% tplpHapPar_group_n_quant$hap,]
hapRecDF <- data.frame()
for(x in 1:(dim(tplpHapPar_quant)[1])) {
  hapRec <- NULL
  for(i in 1:(length(unlist(strsplit(tplpHapPar_quant$hap[x], split = "")))-1)) {
    if( paste0( unlist(strsplit(tplpHapPar_quant$hap[x], split = ""))[i],
                unlist(strsplit(tplpHapPar_quant$hap[x], split = ""))[i+1] )
        %in% c("AB", "BA") ) {
      hapRec <- c(hapRec, 1, 1)
    } else {
      hapRec <- c(hapRec, 0, 0)
    }
  }
  hapRecDF <- rbind(hapRecDF, hapRec)
}
colnames(hapRecDF) <- sort(c(alleles$position[2:(length(alleles$position)-2)],
                             alleles$position[3:(length(alleles$position)-1)]-1))

# From the above complete recombination matrix:
# extract alignments containing only crossovers
hapRecDF_COs <- hapRecDF[rowSums(hapRecDF) == 2,]
# extract alignments containing both crossovers and non-crossovers
hapRecDF_NCOs <- hapRecDF[rowSums(hapRecDF) >= 4,]

# Get haplotypes containing noncrossovers
hap_NCOs <- unique(tplpHapPar_quant[which(rowSums(hapRecDF) >= 4),]$hap)


# List all possible noncrossover patterns for each consecutive 3-marker combination
#ABA_patterns <- c("BA\\w{12}", "ABA\\w{11}", "\\w{1}ABA\\w{10}", "\\w{2}ABA\\w{9}", "\\w{3}ABA\\w{8}",
#                  "\\w{4}ABA\\w{7}", "\\w{5}ABA\\w{6}", "\\w{6}ABA\\w{5}", "\\w{7}ABA\\w{4}",
#                  "\\w{8}ABA\\w{3}", "\\w{9}ABA\\w{2}", "\\w{10}ABA\\w{1}", "\\w{11}ABA")
#BAB_patterns <- c("BAB\\w{11}", "\\w{1}BAB\\w{10}", "\\w{2}BAB\\w{9}", "\\w{3}BAB\\w{8}",
#                  "\\w{4}BAB\\w{7}", "\\w{5}BAB\\w{6}", "\\w{6}BAB\\w{5}", "\\w{7}BAB\\w{4}",
#                  "\\w{8}BAB\\w{3}", "\\w{9}BAB\\w{2}", "\\w{10}BAB\\w{1}", "\\w{11}BAB", "\\w{12}BA")
ABA_patterns <- c(
                  "BA............",
                  "ABA...........",
                  ".ABA..........",
                  "..ABA.........",
                  "...ABA........",
                  "....ABA.......",
                  ".....ABA......",
                  "......ABA.....",
                  ".......ABA....",
                  "........ABA...",
                  ".........ABA..",
                  "..........ABA.",
                  "...........ABA"
                 )
BAB_patterns <- c(
                  "BAB...........",
                  ".BAB..........",
                  "..BAB.........",
                  "...BAB........",
                  "....BAB.......",
                  ".....BAB......",
                  "......BAB.....",
                  ".......BAB....",
                  "........BAB...",
                  ".........BAB..",
                  "..........BAB.",
                  "...........BAB",
                  "............BA"
                 )

# Find matches to ABA_patterns NCO patterns
# including those containing likely sequencing errors (e.g., "AXA", "AIA")
hap_match_ABA_patterns_list_df <- lapply(seq_along(ABA_patterns), function(x) {
  tplpHapVar_ABA <- tplpHapVar[grepl(pattern = ABA_patterns[x],
                                     x = tplpHapVar$hap),]
  tplpHapVar_AXA <- tplpHapVar[grepl(pattern = gsub(pattern = "B",
                                                    replacement = "X",
                                                    x = ABA_patterns[x]), 
                                     x = tplpHapVar$hap),]
  dfx <- bind_rows(list(
    data.frame(hap = as.character(rep(ABA_patterns[x],
                                      dim(tplpHapVar_ABA)[1])),
               freq = as.numeric(rep(dim(tplpHapVar_ABA)[1],
                                     dim(tplpHapVar_ABA)[1])),
               stringsAsFactors = F),
    data.frame(hap = as.character(rep(gsub(pattern = "B",
                                           replacement = "X",
                                           x = ABA_patterns[x]),
                                      dim(tplpHapVar_AXA)[1])),
               freq = as.numeric(rep(dim(tplpHapVar_AXA)[1],
                                     dim(tplpHapVar_AXA)[1])),
               stringsAsFactors = F)
  ), .id = "hapNo")
})
hap_match_ABA_patterns_ratios <- sapply(seq_along(ABA_patterns), function(x) {
  if( !is.na(unique(hap_match_ABA_patterns_list_df[[x]]$freq)[1]) &
      !is.na(unique(hap_match_ABA_patterns_list_df[[x]]$freq)[2]) ) {
    unique(hap_match_ABA_patterns_list_df[[x]]$freq)[1] /
    unique(hap_match_ABA_patterns_list_df[[x]]$freq)[2]
  } else if ( is.na(unique(hap_match_ABA_patterns_list_df[[x]]$freq)[1]) ) {
    1 / (unique(hap_match_ABA_patterns_list_df[[x]]$freq)[2])
  } else if ( is.na(unique(hap_match_ABA_patterns_list_df[[x]]$freq)[2]) ) {
    (unique(hap_match_ABA_patterns_list_df[[x]]$freq)[1]) / 1
  }
})

# Create matrices suitable for plotting as haplotype heat maps
ABAmat_list <- lapply(seq_along(hap_match_ABA_patterns_list_df), function(x) {
  ABAmatx <- matrix(unlist(strsplit(hap_match_ABA_patterns_list_df[[x]]$hap,
                                    split = "")),
                    ncol = dim(tplpHapVar)[2]-1,
                    byrow = T)
  ABAmatx <- cbind(ABAmatx,
                   hap_match_ABA_patterns_list_df[[x]]$hap,
                   hap_match_ABA_patterns_list_df[[x]]$freq)
  colnames(ABAmatx) <- c(colnames(tplpHapVar)[-length(colnames(tplpHapVar))],
                         "hap", "freq")
  ABAmatx
})

ABAmat_list_row_order <- lapply(seq_along(hap_match_ABA_patterns_list_df), function(x) {
  1:dim(hap_match_ABA_patterns_list_df[[x]])[1]
  #order(hap_match_ABA_patterns_list_df[[x]]$freq,
  #      decreasing = T)
})
ABAmat_list_frequencies <- lapply(seq_along(hap_match_ABA_patterns_list_df), function(x) {
  sapply(seq_along(unique(hap_match_ABA_patterns_list_df[[x]]$hap)), function(y) {
    mean( hap_match_ABA_patterns_list_df[[x]][hap_match_ABA_patterns_list_df[[x]]$hap ==
            unique(hap_match_ABA_patterns_list_df[[x]]$hap)[y],]$freq )
  })
})

# Plot a haplotype heat map for matches to each noncrossover haplotype
for(x in seq_along(ABAmat_list)) {
  ABAhtmp <- Heatmap(ABAmat_list[[x]][ ,1:(dim(tplpHapVar)[2]-1)],
                     name = "Allele",
                     col = c("A" = "red", "B" = "blue",
                             "X" = "goldenrod1", "I" = "green2", "N" = "black", "." = "grey60"),
                     row_split = factor(hap_match_ABA_patterns_list_df[[x]]$hap,
                                        levels = unique(as.character(hap_match_ABA_patterns_list_df[[x]]$hap))),
                     row_gap = unit(1.5, "mm"),
                     row_title = paste0(sprintf('%2.0f', ABAmat_list_frequencies[[x]])),
                     row_title_rot = 0,
                     row_title_gp = gpar(fontsize = 10),
                     row_order = ABAmat_list_row_order[[x]],
                     show_row_names = F,
                     #column_split = colnames(mat1[ ,1:(dim(tplpHap_quant)[2]-1)]),
                     #column_gap = unit(1.0, "mm"),
                     #column_title = rep("", length(colnames(mat1[ ,1:(dim(tplpHap_quant)[2]-1)]))),
                     column_title = paste0(ABA_patterns[x],
                                           " haplotype matches in ", sample, " ONT (ratio = ",
                                           round(hap_match_ABA_patterns_ratios[x], digits = 2), ")"),
                     column_title_gp = gpar(fontsize = 20, fontface = "bold"),
                     show_column_names = T,
                     column_names_side = "bottom",
                     column_names_gp = gpar(fontsize = 16),
                     heatmap_legend_param = list(title = bquote(bolditalic("3a") ~ bold("marker allele")),
                                                 title_gp = gpar(fontsize = 16),
                                                 title_position = "topcenter",
                                                 grid_height = unit(6, "mm"),
                                                 grid_width = unit(10, "mm"),
                                                 at = c("A", "B", "X", "."),
#                                                        "X", "I", "N", "."),
                                                 labels = c("Col-0", "Ws-4", "Nonparental SNV", "Any"),
#                                                            "Nonparental SNV", "Nonparental indel", "Missing", "Any"),
                                                 labels_gp = gpar(fontsize = 16),
                                                 ncol = 4, by_row = T),
                     raster_device = "CairoPNG"
                    )
  pdf(paste0(plotDir, sample, "_ONT_ABA_patterns_", ABA_patterns[x], "_matches_recombo_heatmap_v100120.pdf"), height = 18, width = 10)
  draw(ABAhtmp,
       heatmap_legend_side = "bottom")
  dev.off()
}

# Find matches to BAB_patterns NCO patterns
# including those containing likely sequencing errors (e.g., "BXB", "BIB")
hap_match_BAB_patterns_list_df <- lapply(seq_along(BAB_patterns), function(x) {
  tplpHapVar_BAB <- tplpHapVar[grepl(pattern = BAB_patterns[x],
                                     x = tplpHapVar$hap),]
  tplpHapVar_BXB <- tplpHapVar[grepl(pattern = gsub(pattern = "A",
                                                    replacement = "X",
                                                    x = BAB_patterns[x]), 
                                     x = tplpHapVar$hap),]
  dfx <- bind_rows(list(
    data.frame(hap = as.character(rep(BAB_patterns[x],
                                      dim(tplpHapVar_BAB)[1])),
               freq = as.numeric(rep(dim(tplpHapVar_BAB)[1],
                                     dim(tplpHapVar_BAB)[1])),
               stringsAsFactors = F),
    data.frame(hap = as.character(rep(gsub(pattern = "A",
                                           replacement = "X",
                                           x = BAB_patterns[x]),
                                      dim(tplpHapVar_BXB)[1])),
               freq = as.numeric(rep(dim(tplpHapVar_BXB)[1],
                                     dim(tplpHapVar_BXB)[1])),
               stringsAsFactors = F)
  ), .id = "hapNo")
})
hap_match_BAB_patterns_ratios <- sapply(seq_along(BAB_patterns), function(x) {
  if( !is.na(unique(hap_match_BAB_patterns_list_df[[x]]$freq)[1]) &
      !is.na(unique(hap_match_BAB_patterns_list_df[[x]]$freq)[2]) ) {
    unique(hap_match_BAB_patterns_list_df[[x]]$freq)[1] /
    unique(hap_match_BAB_patterns_list_df[[x]]$freq)[2]
  } else if ( is.na(unique(hap_match_BAB_patterns_list_df[[x]]$freq)[1]) ) {
    1 / (unique(hap_match_BAB_patterns_list_df[[x]]$freq)[2])
  } else if ( is.na(unique(hap_match_BAB_patterns_list_df[[x]]$freq)[2]) ) {
    (unique(hap_match_BAB_patterns_list_df[[x]]$freq)[1]) / 1
  }
})

# Create matrices suitable for plotting as haplotype heat maps
BABmat_list <- lapply(seq_along(hap_match_BAB_patterns_list_df), function(x) {
  BABmatx <- matrix(unlist(strsplit(hap_match_BAB_patterns_list_df[[x]]$hap,
                                    split = "")),
                    ncol = dim(tplpHapVar)[2]-1,
                    byrow = T)
  BABmatx <- cbind(BABmatx,
                   hap_match_BAB_patterns_list_df[[x]]$hap,
                   hap_match_BAB_patterns_list_df[[x]]$freq)
  colnames(BABmatx) <- c(colnames(tplpHapVar)[-length(colnames(tplpHapVar))],
                         "hap", "freq")
  BABmatx
})

BABmat_list_row_order <- lapply(seq_along(hap_match_BAB_patterns_list_df), function(x) {
  1:dim(hap_match_BAB_patterns_list_df[[x]])[1]
  #order(hap_match_BAB_patterns_list_df[[x]]$freq,
  #      decreasing = T)
})
BABmat_list_frequencies <- lapply(seq_along(hap_match_BAB_patterns_list_df), function(x) {
  sapply(seq_along(unique(hap_match_BAB_patterns_list_df[[x]]$hap)), function(y) {
    mean( hap_match_BAB_patterns_list_df[[x]][hap_match_BAB_patterns_list_df[[x]]$hap ==
            unique(hap_match_BAB_patterns_list_df[[x]]$hap)[y],]$freq )
  })
})

# Plot a haplotype heat map for matches to each noncrossover haplotype
for(x in seq_along(BABmat_list)) {
  BABhtmp <- Heatmap(BABmat_list[[x]][ ,1:(dim(tplpHapVar)[2]-1)],
                     name = "Allele",
                     col = c("A" = "red", "B" = "blue",
                             "X" = "goldenrod1", "I" = "green2", "N" = "black", "." = "grey60"),
                     row_split = factor(hap_match_BAB_patterns_list_df[[x]]$hap,
                                        levels = unique(as.character(hap_match_BAB_patterns_list_df[[x]]$hap))),
                     row_gap = unit(1.5, "mm"),
                     row_title = paste0(sprintf('%2.0f', BABmat_list_frequencies[[x]])),
                     row_title_rot = 0,
                     row_title_gp = gpar(fontsize = 10),
                     row_order = BABmat_list_row_order[[x]],
                     show_row_names = F,
                     #column_split = colnames(mat1[ ,1:(dim(tplpHap_quant)[2]-1)]),
                     #column_gap = unit(1.0, "mm"),
                     #column_title = rep("", length(colnames(mat1[ ,1:(dim(tplpHap_quant)[2]-1)]))),
                     column_title = paste0(BAB_patterns[x],
                                           " haplotype matches in ", sample, " ONT (ratio = ",
                                           round(hap_match_BAB_patterns_ratios[x], digits = 2), ")"),
                     column_title_gp = gpar(fontsize = 20, fontface = "bold"),
                     show_column_names = T,
                     column_names_side = "bottom",
                     column_names_gp = gpar(fontsize = 16),
                     heatmap_legend_param = list(title = bquote(bolditalic("3a") ~ bold("marker allele")),
                                                 title_gp = gpar(fontsize = 16),
                                                 title_position = "topcenter",
                                                 grid_height = unit(6, "mm"),
                                                 grid_width = unit(10, "mm"),
                                                 at = c("A", "B", "X", "."),
#                                                        "X", "I", "N", "."),
                                                 labels = c("Col-0", "Ws-4", "Nonparental SNV", "Any"),
#                                                            "Nonparental SNV", "Nonparental indel", "Missing", "Any"),
                                                 labels_gp = gpar(fontsize = 16),
                                                 ncol = 4, by_row = T),
                     raster_device = "CairoPNG"
                    )
  pdf(paste0(plotDir, sample, "_ONT_BAB_patterns_", BAB_patterns[x], "_matches_recombo_heatmap_v100120.pdf"), height = 18, width = 10)
  draw(BABhtmp,
       heatmap_legend_side = "bottom")
  dev.off()
}

# Remove high-frequency haplotypes that match error-prone noncrossover patterns
threshold_ratio <- 2
for(x in seq_along(ABA_patterns[hap_match_ABA_patterns_ratios < threshold_ratio])) {
  print(ABA_patterns[hap_match_ABA_patterns_ratios < threshold_ratio][x])
  print(which(grepl(pattern = ABA_patterns[hap_match_ABA_patterns_ratios < threshold_ratio][x],
              x = tplpHapPar_group_n_quant_tmp$hap,
              perl = T)))
  print(tplpHapPar_group_n_quant_tmp[which(grepl(pattern = ABA_patterns[hap_match_ABA_patterns_ratios < threshold_ratio][x],
                                        x = tplpHapPar_group_n_quant_tmp$hap,
                                        perl = T)),])
  tplpHapPar_group_n_quant_tmp <- tplpHapPar_group_n_quant_tmp[which(!grepl(pattern = ABA_patterns[hap_match_ABA_patterns_ratios < threshold_ratio][x],
                                                                      x = tplpHapPar_group_n_quant_tmp$hap,
                                                                      perl = T)),]
}
for(x in seq_along(BAB_patterns[hap_match_BAB_patterns_ratios < threshold_ratio])) {
  print(BAB_patterns[hap_match_BAB_patterns_ratios < threshold_ratio][x])
  print(which(grepl(pattern = BAB_patterns[hap_match_BAB_patterns_ratios < threshold_ratio][x],
              x = tplpHapPar_group_n_quant_tmp$hap,
              perl = T)))
  print(tplpHapPar_group_n_quant_tmp[which(grepl(pattern = BAB_patterns[hap_match_BAB_patterns_ratios < threshold_ratio][x],
                                        x = tplpHapPar_group_n_quant_tmp$hap,
                                        perl = T)),])
  tplpHapPar_group_n_quant_tmp <- tplpHapPar_group_n_quant_tmp[which(!grepl(pattern = BAB_patterns[hap_match_BAB_patterns_ratios < threshold_ratio][x],
                                                                      x = tplpHapPar_group_n_quant_tmp$hap,
                                                                      perl = T)),]
}

# Find matches to high-frequency apparent noncrossover haplotypes (allowing up to 1 mismatch),
# including those containing nonparental variants (likely sequencing errors)
# Then get the frequency of occurrence of each of these matching haplotypes
hap_match_hapNCO_group_n_list <- lapply(seq_along(hap_NCOs), function(x) {
  match_index <- vmatchPattern(pattern = hap_NCOs[x],
                               subject = BStringSet(tplpHapVar$hap),
                               max.mismatch = 1,
                               min.mismatch = 0,
                               with.indels = F, fixed = T, algorithm = "auto")
  # Get the number of matches to hap_NCO[x] per subject element
  nmatch_per_hap <- elementNROWS(match_index)
  # Get haplotypes matching the noncrossover haplotype
  tplpHapVar_match_hapNCOx <- tplpHapVar[which(nmatch_per_hap != 0),]
  # For each matching haplotype, count occurrences
  tplpHapVar_match_hapNCOx_group_n <- tplpHapVar_match_hapNCOx %>%
    group_by(hap) %>%
    summarize(n())
  # Subset haplotypes to include only those that match the noncrossover haplotype exactly,
  # and those that contain either a nonparental SNV ("X"), a nonparental indel ("I"), or missing data ("N")
  tplpHapVar_match_hapNCOx_group_n[tplpHapVar_match_hapNCOx_group_n$hap %in% hap_NCOs[x] |
                                   grepl(pattern = "X", x = tplpHapVar_match_hapNCOx_group_n$hap, fixed = T) |
                                   grepl(pattern = "I", x = tplpHapVar_match_hapNCOx_group_n$hap, fixed = T) |
                                   grepl(pattern = "N", x = tplpHapVar_match_hapNCOx_group_n$hap, fixed = T) &
                                   tplpHapVar_match_hapNCOx_group_n$'n()' > 0,]
})

# Convert haplotype frequencies into proportions and percentages
hap_match_hapNCO_group_n_list_prop <- lapply(seq_along(hap_match_hapNCO_group_n_list), function(x) {
  ceiling( ( hap_match_hapNCO_group_n_list[[x]]$'n()' /
             (sum(hap_match_hapNCO_group_n_list[[x]]$'n()')) ) * 100000 )
})

hap_match_hapNCO_group_n_list_df <- lapply(seq_along(hap_match_hapNCO_group_n_list), function(x) {
  dfx <- bind_rows(lapply(seq_along(hap_match_hapNCO_group_n_list_prop[[x]]), function(y) {
    data.frame(hap = as.character(rep(hap_match_hapNCO_group_n_list[[x]]$hap[y],
                                      hap_match_hapNCO_group_n_list[[x]]$'n()'[y])),
               freq = as.numeric(rep(hap_match_hapNCO_group_n_list[[x]]$'n()'[y],
                                     hap_match_hapNCO_group_n_list[[x]]$'n()'[y])),
               prop = as.numeric(rep(hap_match_hapNCO_group_n_list_prop[[x]][y],
                                     hap_match_hapNCO_group_n_list[[x]]$'n()'[y])),
               perc = as.numeric(rep(hap_match_hapNCO_group_n_list_prop[[x]][y]/1000,
                                     hap_match_hapNCO_group_n_list[[x]]$'n()'[y])),
               stringsAsFactors = F)
  }), .id = "hapNo")
  dfx[sort.int(dfx$freq,
               decreasing = T,
               index.return = T)$ix,]
})

# Create matrices suitable for plotting as haplotype heat maps
NCOmat_list <- lapply(seq_along(hap_match_hapNCO_group_n_list_df), function(x) {
  NCOmatx <- matrix(unlist(strsplit(hap_match_hapNCO_group_n_list_df[[x]]$hap,
                                    split = "")),
                    ncol = dim(tplpHapVar)[2]-1,
                    byrow = T)
  NCOmatx <- cbind(NCOmatx,
                   hap_match_hapNCO_group_n_list_df[[x]]$hap,
                   hap_match_hapNCO_group_n_list_df[[x]]$freq,
                   hap_match_hapNCO_group_n_list_df[[x]]$prop,
                   hap_match_hapNCO_group_n_list_df[[x]]$perc)
  colnames(NCOmatx) <- c(colnames(tplpHapVar)[-length(colnames(tplpHapVar))],
                         "hap", "freq", "prop", "perc")
  NCOmatx
})

NCOmat_list_row_order <- lapply(seq_along(hap_match_hapNCO_group_n_list_df), function(x) {
  order(hap_match_hapNCO_group_n_list_df[[x]]$freq,
        decreasing = T)
})
NCOmat_list_frequencies <- lapply(seq_along(hap_match_hapNCO_group_n_list_df), function(x) {
  sapply(seq_along(unique(hap_match_hapNCO_group_n_list_df[[x]]$hap)), function(y) {
    mean( hap_match_hapNCO_group_n_list_df[[x]][hap_match_hapNCO_group_n_list_df[[x]]$hap ==
            unique(hap_match_hapNCO_group_n_list_df[[x]]$hap)[y],]$freq )
  })
})

# Plot a haplotype heat map for matches to each noncrossover haplotype
for(x in seq_along(NCOmat_list)) {
  NCOhtmp <- Heatmap(NCOmat_list[[x]][ ,1:(dim(tplpHapVar)[2]-1)],
                     name = "Allele",
                     col = c("A" = "red", "B" = "blue",
                             "X" = "goldenrod1", "I" = "green2", "N" = "grey40"),
                     row_split = factor(hap_match_hapNCO_group_n_list_df[[x]]$hap,
                                        levels = unique(as.character(hap_match_hapNCO_group_n_list_df[[x]]$hap))),
                     row_gap = unit(1.5, "mm"),
                     row_title = paste0(sprintf('%2.0f', NCOmat_list_frequencies[[x]])),
                     row_title_rot = 0,
                     row_title_gp = gpar(fontsize = 10),
                     row_order = NCOmat_list_row_order[[x]],
                     show_row_names = F,
                     #column_split = colnames(mat1[ ,1:(dim(tplpHapPar_quant)[2]-1)]),
                     #column_gap = unit(1.0, "mm"),
                     #column_title = rep("", length(colnames(mat1[ ,1:(dim(tplpHapPar_quant)[2]-1)]))),
                     column_title = paste0("NCO haplotype ", hap_NCOs[x],
                                           " matches in ", sample, " ONT"),
                     column_title_gp = gpar(fontsize = 20, fontface = "bold"),
                     show_column_names = T,
                     column_names_side = "bottom",
                     column_names_gp = gpar(fontsize = 16),
                     heatmap_legend_param = list(title = bquote(bolditalic("3a") ~ bold("marker allele")),
                                                 title_gp = gpar(fontsize = 16),
                                                 title_position = "topcenter",
                                                 grid_height = unit(6, "mm"),
                                                 grid_width = unit(10, "mm"),
                                                 labels = c("Col-0", "Ws-4",
                                                            "Nonparental SNV", "Nonparental indel", "Missing"),
                                                 labels_gp = gpar(fontsize = 16),
                                                 ncol = 2, by_row = T),
                     raster_device = "CairoPNG"
                    )
  pdf(paste0(plotDir, sample, "_ONT_NCO_haplotype_", hap_NCOs[x], "_matches_recombo_heatmap_v080120.pdf"), height = 18, width = 10)
  draw(NCOhtmp,
       heatmap_legend_side = "bottom")
  dev.off()
}

af <- data.frame()
for(x in 1:dim(plp2)[1]) {
  marker_total <- length( plp2[x,5:dim(plp2)[2]] )
  marker_A <- sum( ( plp2[x,5:dim(plp2)[2]] %in% c("AA") ) )
  marker_B <- sum( ( plp2[x,5:dim(plp2)[2]] %in% c("BB") ) )
  marker_X <- sum( ( plp2[x,5:dim(plp2)[2]] %in% c("XX") ) )
  marker_N <- sum( ( plp2[x,5:dim(plp2)[2]] %in% c("*") ) )
  marker_I <- sum(!( plp2[x,5:dim(plp2)[2]] %in% c("AA", "BB", "XX", "*") ) )
  stopifnot(marker_total ==
            sum(marker_A, marker_B, marker_X, marker_N, marker_I))
  af_x <- data.frame(marker = alleles$pos[x],
                     A = marker_A/marker_total,
                     B = marker_B/marker_total,
                     X = marker_X/marker_total,
                     I = marker_I/marker_total,
                     N = marker_N/marker_total)
  af <- rbind(af, af_x)
}

# Remove markers within allele-specific primer binding sites
af <- af[c(-1, -dim(af)[1]), ]
af_tidy <- gather(data = af,
                  key = allele,
                  value = af,
                  -marker)
af_tidy$allele <- factor(af_tidy$allele,
                         levels = unique(af_tidy$allele))



# For each recombination matrix (complete and subsetted),
# calculate cM/Mb in each marker interval
cMMb <- data.frame(window = as.integer(colnames(hapRecDF)),
                   All = as.vector( ( (colSums(hapRecDF)/dim(hapRecDF)[1]) /
                                      (widths/1e6) ) * cMscale ),
                   COs = as.vector( ( (colSums(hapRecDF_COs)/dim(hapRecDF)[1]) /
                                      (widths/1e6) ) * cMscale ),
                   NCOs = as.vector( ( (colSums(hapRecDF_NCOs)/dim(hapRecDF)[1]) /
                                       (widths/1e6) ) * cMscale )
                  )
cMMb_tidy <- gather(data = cMMb,
                    key = aln,
                    value = cMMb,
                    -window)
cMMb_tidy$aln <- factor(cMMb_tidy$aln,
                        levels = unique(cMMb_tidy$aln))

cM <- data.frame(window = as.integer(colnames(hapRecDF)),
                 All = as.vector( ( (colSums(hapRecDF)/dim(hapRecDF)[1]) * 100 ) * cMscale ),
                 COs = as.vector( ( (colSums(hapRecDF_COs)/dim(hapRecDF)[1]) * 100 ) * cMscale ),
                 NCOs = as.vector( ( (colSums(hapRecDF_NCOs)/dim(hapRecDF)[1]) * 100 ) * cMscale ))
cM_tidy <- gather(data = cM,
                  key = aln,
                  value = cM,
                  -window)
cM_tidy$aln <- factor(cM_tidy$aln,
                      levels = unique(cM_tidy$aln))

# Generate more complete summary (including CO and NCO recombination event counts)
rec_summary <- data.frame(window = as.integer(colnames(hapRecDF)),
                          width = widths,
                          total_alignments = dim(hapRecDF)[1],
                          cMscale = cMscale,
                          All_rec_events = as.vector( colSums(hapRecDF) ),
                          COs_rec_events = as.vector( colSums(hapRecDF_COs) ),
                          NCOs_COs_rec_events = as.vector( colSums(hapRecDF_NCOs) ),
                          All_cMMb = as.vector( ( (colSums(hapRecDF)/dim(hapRecDF)[1]) /
                                                  (widths/1e6) ) * cMscale ),
                          COs_cMMb = as.vector( ( (colSums(hapRecDF_COs)/dim(hapRecDF)[1]) /
                                                  (widths/1e6) ) * cMscale ),
                          NCOs_COs_cMMb = as.vector( ( (colSums(hapRecDF_NCOs)/dim(hapRecDF)[1]) /
                                                       (widths/1e6) ) * cMscale )
                         )
write.table(rec_summary,
            file = paste0(plotDir, sample, "_ONT_recombo_summary_v100120.tsv"),
            quote = F, sep = "\t", row.names = F, col.names = T)

# Complete amplicon extends from 634089 (20 nt upstream of 634109)
# to 639952 (18 nt downstream of 639934)

# Define legend labels
alnNames <- c(paste0("All (",
                     prettyNum(dim(hapRecDF)[1],
                               big.mark = ",", trim = T),
                     ")"),
              paste0("COs (",
                     prettyNum(dim(hapRecDF_COs)[1],
                               big.mark = ",", trim = T),
                     ")"),
              paste0("NCOs & COs (",
                     prettyNum(dim(hapRecDF_NCOs)[1],
                               big.mark = ",", trim = T),
                     ")"))
alnColours <- c("dodgerblue2", "purple", "green2")
makeTransparent <- function(thisColour, alpha = 180)
{
  newColour <- col2rgb(thisColour)
  apply(newColour, 2, function(x) {
    rgb(red = x[1], green = x[2], blue = x[3],
        alpha = alpha, maxColorValue = 300)
  })
}
alnColours <- makeTransparent(alnColours)
legendPos <- as.numeric(unlist(strsplit("0.01,0.96",
                                        split = ",")))
legendLabs <- lapply(seq_along(alnNames), function(x) {
  grobTree(textGrob(bquote(.(alnNames[x])),
                    x = legendPos[1], y = legendPos[2]-((x-1)*0.06), just = "left",
                    gp = gpar(col = alnColours[x], fontsize = 18)))
})  

# Plot recombination rates for group of alignments
# (all, COs only, both NCOs and COs)
ggObj_cMMb <- ggplot(data = cMMb_tidy,
                     mapping = aes(x = window,
                                   y = cMMb,
                                   group = aln)) +
  geom_line(data = cMMb_tidy,
            mapping = aes(colour = aln),
            size = 2) +
  scale_colour_manual(values = alnColours) +
  scale_x_continuous(breaks = c(alleles$position[2:(length(alleles$position)-1)]),
                     labels = c(as.character(alleles$position[2:(length(alleles$position)-1)]))) +
  scale_y_continuous(limits = c(-50, 500),
                     labels = function(x) sprintf("%3.0f", as.numeric(x))) +
  geom_vline(xintercept = c(alleles$position[2:(length(alleles$position)-1)]),
             linetype = "dashed",
             size = 0.5) +
  # Add genes within 3a hotspot
  # 3       634653  637284  +       AT3G02880.1
  # 3       638021  639055  -       AT3G02885.1
  geom_segment(mapping = aes(x = 634653, y = -35,
                             xend = 637284, yend = -35),
               arrow = arrow(angle = 10, type = "closed"), size = 1.5, linejoin = "round") +
  geom_segment(mapping = aes(x = 639055, y = -35,
                             xend = 638021, yend = -35),
               arrow = arrow(angle = 10, type = "closed"), size = 1.5, linejoin = "round") +
  labs(x = bquote(italic("3a") ~ "marker"),
       y = bquote(cM*"/"*Mb~""%*%~.(cMscale))) +
  annotation_custom(legendLabs[[1]]) +
  annotation_custom(legendLabs[[2]]) +
  annotation_custom(legendLabs[[3]]) +
  theme_bw() +
  theme(
        axis.ticks = element_line(size = 1.0, colour = "black"),
        axis.ticks.length = unit(0.25, "cm"),
        axis.text.x = element_text(size = 18, colour = "black", family = "Luxi Mono", angle = 90, vjust = 0.5),
        axis.text.y = element_text(size = 18, colour = "black", family = "Luxi Mono"),
        axis.title = element_text(size = 30, colour = "black"),
        legend.position = "none",
        panel.grid = element_blank(),
        panel.border = element_rect(size = 3.5, colour = "black"),
        panel.background = element_blank(),
        plot.margin = unit(c(0.3,1.2,0.0,0.3), "cm"),
        plot.title = element_text(hjust = 0.5, size = 30)) +
  ggtitle(bquote(bold(.(sample) ~ "ONT (" *
                      .(prettyNum(dim(hapRecDF)[1],
                             big.mark = ",", trim = T)) *
                      " alignments)")))

ggObj_cM <- ggplot(data = cM_tidy,
                   mapping = aes(x = window,
                                 y = cM,
                                 group = aln)) +
  geom_line(data = cM_tidy,
            mapping = aes(colour = aln),
            size = 2) +
  scale_colour_manual(values = alnColours) +
  scale_x_continuous(breaks = c(alleles$position[2:(length(alleles$position)-1)]),
                     labels = c(as.character(alleles$position[2:(length(alleles$position)-1)]))) +
  scale_y_continuous(limits = c(-0.6, 6.5),
		     labels = function(x) sprintf("%1.1f", as.numeric(x))) +
  geom_vline(xintercept = c(alleles$position[2:(length(alleles$position)-1)]),
             linetype = "dashed",
             size = 0.5) +
  geom_segment(mapping = aes(x = 634653, y = -0.4,
                             xend = 637284, yend = -0.4),
               arrow = arrow(angle = 10, type = "closed"), size = 1.5, linejoin = "round") +
  geom_segment(mapping = aes(x = 639055, y = -0.4,
                             xend = 638021, yend = -0.4),
               arrow = arrow(angle = 10, type = "closed"), size = 1.5, linejoin = "round") +
  labs(x = bquote(italic("3a") ~ "marker"),
       y = bquote(cM~""%*%~.(cMscale))) +
  annotation_custom(legendLabs[[1]]) +
  annotation_custom(legendLabs[[2]]) +
  annotation_custom(legendLabs[[3]]) +
  theme_bw() +
  theme(
        axis.ticks = element_line(size = 1.0, colour = "black"),
        axis.ticks.length = unit(0.25, "cm"),
        axis.text.x = element_text(size = 18, colour = "black", family = "Luxi Mono", angle = 90, vjust = 0.5),
        axis.text.y = element_text(size = 18, colour = "black", family = "Luxi Mono"),
        axis.title = element_text(size = 30, colour = "black"),
        legend.position = "none",
        panel.grid = element_blank(),
        panel.border = element_rect(size = 3.5, colour = "black"),
        panel.background = element_blank(),
        plot.margin = unit(c(0.3,1.2,0.0,0.3), "cm"),
        plot.title = element_text(hjust = 0.5, size = 30)) +
  ggtitle(bquote(bold(.(sample) ~ "ONT (" *
                      .(prettyNum(dim(hapRecDF)[1],
                             big.mark = ",", trim = T)) *
                      " alignments)")))
ggObjGA_combined <- grid.arrange(ggObj_cMMb,
                                 ggObj_cM,
                                 nrow = 2, as.table = F)
                                                    
ggsave(paste0(plotDir, sample, "_ONT_cMMb_cM_v100120.pdf"),
       plot = ggObjGA_combined,
       height = 6.5*2, width = 20, limitsize = F)



# Convert haplotype frequencies into proportions
# for heat map plotting
tplpHapPar_group_n_quant_prop <- ceiling( ( tplpHapPar_group_n_quant$`n()` /
                                         (sum(tplpHapPar_group_n_quant$`n()`)) ) * 100000 )

tplpHapPar_group_n_quant_prop_hap <- bind_rows(lapply(seq_along(tplpHapPar_group_n_quant_prop), function(x) {
  data.frame(hap = as.character(rep(tplpHapPar_group_n_quant$hap[x],
                                    tplpHapPar_group_n_quant_prop[x])),
             prop = as.numeric(rep(tplpHapPar_group_n_quant_prop[x],
                                   tplpHapPar_group_n_quant_prop[x])),
             perc = as.numeric(rep(tplpHapPar_group_n_quant_prop[x]/1000,
                                   tplpHapPar_group_n_quant_prop[x])),
             stringsAsFactors = F)
}), .id = "hapNo")

tplpHapPar_group_n_quant_prop_hap_sort <- tplpHapPar_group_n_quant_prop_hap[sort.int(tplpHapPar_group_n_quant_prop_hap$prop,
                                                                               decreasing = T,
                                                                               index.return = T)$ix,]
mat1 <- matrix(unlist(strsplit(tplpHapPar_group_n_quant_prop_hap_sort$hap,
                               split = "")),
               ncol = dim(tplpHapPar_quant)[2]-1,
               byrow = T)
mat1 <- cbind(mat1,
              tplpHapPar_group_n_quant_prop_hap_sort$hap,
              tplpHapPar_group_n_quant_prop_hap_sort$prop,
              tplpHapPar_group_n_quant_prop_hap_sort$perc)
colnames(mat1) <- c(colnames(tplpHapPar_quant)[-length(colnames(tplpHapPar_quant))],
                    "hap", "prop", "perc")
row_order <- order(tplpHapPar_group_n_quant_prop_hap_sort$perc,
                   decreasing = T)
proportions <- sapply(seq_along(unique(tplpHapPar_group_n_quant_prop_hap_sort$hap)), function(x) {
  mean(tplpHapPar_group_n_quant_prop_hap_sort[tplpHapPar_group_n_quant_prop_hap_sort$hap ==
         unique(tplpHapPar_group_n_quant_prop_hap_sort$hap)[x],]$perc)
})

htmp <- Heatmap(mat1[ ,1:(dim(tplpHapPar_quant)[2]-1)],
                name = "Allele",
                col = c("A" = "red", "B" = "blue", "-" = "grey40"),
                row_split = factor(tplpHapPar_group_n_quant_prop_hap_sort$hap,
                                   levels = unique(as.character(tplpHapPar_group_n_quant_prop_hap_sort$hap))),
                row_gap = unit(1.5, "mm"),
                row_title = paste0(sprintf('%.3f', proportions), "%"),
                row_title_rot = 0,
                row_title_gp = gpar(fontsize = 10),
                row_order = row_order,
                show_row_names = F,
                #column_split = colnames(mat1[ ,1:(dim(tplpHapPar_quant)[2]-1)]),
                #column_gap = unit(1.0, "mm"),
                #column_title = rep("", length(colnames(mat1[ ,1:(dim(tplpHapPar_quant)[2]-1)]))),
                column_title = paste0(sample, " ONT (",
                                      prettyNum(dim(hapRecDF)[1],
                                                big.mark = ",", trim = T),
                                      " alignments)"),
                column_title_gp = gpar(fontsize = 20, fontface = "bold"),
                show_column_names = T,
                column_names_side = "bottom",
                column_names_gp = gpar(fontsize = 16),
                heatmap_legend_param = list(title = bquote(bolditalic("3a") ~ bold("marker allele")),
                                            title_gp = gpar(fontsize = 16),
                                            title_position = "topcenter",
                                            grid_height = unit(6, "mm"),
                                            grid_width = unit(10, "mm"),
                                            labels = c("Col-0", "Ws-4"),
                                            labels_gp = gpar(fontsize = 16),
                                            ncol = 2, by_row = T),
                raster_device = "CairoPNG"
               )
pdf(paste0(plotDir, sample, "_ONT_recombo_heatmap_v100120.pdf"), height = 18, width = 10)
draw(htmp,
     heatmap_legend_side = "bottom")
dev.off()
