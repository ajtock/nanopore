#!/applications/R/R-3.5.0/bin/Rscript

# Convert samtools pileup file into a haplotype matrix
# for visualisation of recombination over interval

#sample <- "barcode1_120"
#MAPQ <- 60

args <- commandArgs(trailingOnly = T)
sample <- args[1]
MAPQ <- args[2]

setwd("/home/ajt200/analysis/nanopore/pollen_typing/")
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggthemes)
library(grid)
library(gridExtra)
library(extrafont)
library(parallel)
library(doParallel)
registerDoParallel(cores = detectCores())
print("Currently registered parallel backend name, version and cores")
print(getDoParName())
print(getDoParVersion())
print(getDoParWorkers())

# Load reference and alternate alleles
alleles <- read.table("3a_SNPs_in_Col_and_Ws.tsv",
                      header = T)

# Load pileup containing per-alignment genotype information,
# as generated by samtools mpileup
plp <- read.table(paste0("minimap2_TAIR10_",
                         sample,
                         "_sorted_primary_MAPQ", MAPQ, ".plp"),
                  header = F, sep = "\t",
                  quote = "", comment.char = "",
                  stringsAsFactors = F)

# Append the first 3 columns, the alternate allele, and columns
# corresponding to per-alignment file genotype
plp <- data.frame(plp[ ,1:3],
                  alleles[ ,4],
                  plp[ ,seq(from = 5, 
                            to = dim(plp)[2]-1,
                            by = 3)])
colnames(plp) <- c("chr", "pos", "ref", "alt",
                   seq(1:(dim(plp)[2]-4)))
# Replace factors with characters
factorColumns <- sapply(plp, is.factor)
plp[factorColumns] <- lapply(plp[factorColumns], as.character)
plpHap <- plp

# Re-encode haplotypes using genotype naming convention
# to avoid incorrect encoding of adenosine bases
# Col-0 as "AA", Ws-4 as "BB", "*" and all others as "-" 
for(x in 1:(dim(plpHap)[1])) {
  for(y in 5:(dim(plpHap)[2])) {
    if( plpHap[x,y] %in% c(".", ",") ) {
      plpHap[x,y] <- "AA"
    } else if( plpHap[x,y] %in% c(plpHap[x,4],
                                  tolower(plpHap[x,4])) ) {
      plpHap[x,y] <- "BB"
    } else {
      plpHap[x,y] <- "-"
    }
  }
}
# Convert genotype naming convention into
# haplotype naming convention as we cannot derive
# each allele from single-molecule sequencing
plpHap[] <- lapply(plpHap, function(x) as.character(gsub("AA", "A", x)))
plpHap[] <- lapply(plpHap, function(x) as.character(gsub("BB", "B", x)))

# Transpose haplotype matrix for sorting
tplpHap <- data.frame(t(plpHap[,5:dim(plpHap)[2]]))
colnames(tplpHap) <- as.integer(plpHap$pos)

# As the first (leftmost) and last (rightmost) markers are
# within the primer binding sites and may be artificially converted
# into an allele within the allele-specific primer, strip these markers
# (first and last columns) from tplpHap
tplpHap <- tplpHap[,2:(dim(tplpHap)[2]-1)]

# Add column representing haplotypes as character strings
stringHap <- sapply(1:(dim(tplpHap)[1]), function(x) {
  paste0(as.character(as.matrix(tplpHap[x,])), collapse = "")
})
tplpHap <- data.frame(tplpHap,
                      hap = stringHap)
colnames(tplpHap) <- c(as.integer(plpHap$pos[2:(length(plpHap$pos)-1)]),
                       "hap")
# Replace factors with characters
factorColumns <- sapply(tplpHap, is.factor)
tplpHap[factorColumns] <- lapply(tplpHap[factorColumns], as.character)

# Retain only rows that contain both parental haplotypes
tplpHap <- tplpHap[grepl("A", tplpHap$hap) &
                   grepl("B", tplpHap$hap),]


### YET TO BE DONE
# Extract alignments with complete haplotypes
# Identify haplotypes in the top 5th percentile,
# determine corresponding proportions for these haplotypes,
# and impute missing data for alignments with incomplete haplotypes
# based on these proportions
tplpHap_complete <- tplpHap[!grepl("-", tplpHap$hap),]
tplpHap_complete_n <- tplpHap_complete %>%
  group_by(hap) %>%
  summarize(n())
tplpHap_complete_n_quant <- tplpHap_complete_n %>%
  filter(`n()` > quantile(`n()`, 0.95))
### YET TO BE DONE


# Apply a haplotype imputation approach which
# is informed by haplotypes at flanking markers
# and, later, by haplotypes within other alignments

# For imputation of missing haplotypes that are not at
# the ends of an alignment, they must be flanked by
# two of the same parental allele, one on each side
# (e.g., for "AAAA-AAA-AAAAA-BB", only the first and second "-",
#  and not the third "-", would be imputed as "A")
# For Col-0 (A) alleles
while( sum(grepl(pattern = "A(-+)A",
                 x = tplpHap$hap,
                 perl = T)) > 0 ) {
  for(x in 1:length(tplpHap$hap)) {
    if( grepl(pattern = "A(-+)A",
              x = tplpHap$hap[x],
              perl = T) ) {
      tplpHap$hap[x] <- sub(pattern = "A(-+)A",
                            replacement = paste0("A",
                                                 paste0(rep(x = "A",
                                                            times = attr(regexpr(pattern = "A(-+)A",
                                                                                 text = tplpHap$hap[x],
                                                                                 perl = T),
                                                                         'capture.length')[1]),
                                                        collapse = ""),
                                                 "A"),
                            x = tplpHap$hap[x],
                            perl = T)
    }
  }
}
# For Ws-4 (B) alleles
while( sum(grepl(pattern = "B(-+)B",
                 x = tplpHap$hap,
                 perl = T)) > 0 ) {
  for(x in 1:length(tplpHap$hap)) {
    if( grepl(pattern = "B(-+)B",
              x = tplpHap$hap[x],
              perl = T) ) {
      tplpHap$hap[x] <- sub(pattern = "B(-+)B",
                            replacement = paste0("B",
                                                 paste0(rep(x = "B",
                                                            times = attr(regexpr(pattern = "B(-+)B",
                                                                                 text = tplpHap$hap[x],
                                                                                 perl = T),
                                                                         'capture.length')[1]),
                                                        collapse = ""),
                                                 "B"),
                            x = tplpHap$hap[x],
                            perl = T)
    }
  }
}

# Impute missing haplotypes at the ends of an alignment based
# on the haplotype at the nearest marker(s)

# As an allele-specific primer on the left binds only Col-0 (A) alleles,
# impute missing haplotypes at the left-hand side (beginning) of alignments
# that have a Col-0 (A) allele at a marker on their right
# (e.g., for "----ABBBBBBBBBA-", only the left-hand "----" and
#  not the right-hand "-" would be imputed as "A")
# For Col-0 (A) alleles
# left-hand side (beginning) of alignments
while( sum(grepl(pattern = "^(-+)A",
                 x = tplpHap$hap,
                 perl = T)) > 0 ) {
  for(x in 1:length(tplpHap$hap)) {
    if( grepl(pattern = "^(-+)A",
              x = tplpHap$hap[x],
              perl = T) ) {
      tplpHap$hap[x] <- sub(pattern = "^(-+)A",
                            replacement = paste0(paste0(rep(x = "A",
                                                            times = attr(regexpr(pattern = "^(-+)A",
                                                                                 text = tplpHap$hap[x],
                                                                                 perl = T),
                                                                         'capture.length')[1]),
                                                        collapse = ""),
                                                 "A"),
                            x = tplpHap$hap[x],
                            perl = T)
    }
  }
}
## right-hand side (end) of alignments
## (to be used for Col-0 (A) alleles ONLY where a Col-0-specific
##  primer binds the right-hand side of the amplicon)
#while( sum(grepl(pattern = "A(-+)$",
#                 x = tplpHap$hap,
#                 perl = T)) > 0 ) {
#  for(x in 1:length(tplpHap$hap)) {
#    if( grepl(pattern = "A(-+)$",
#              x = tplpHap$hap[x],
#              perl = T) ) {
#      tplpHap$hap[x] <- sub(pattern = "A(-+)$",
#                            replacement = paste0("A",
#                                                 paste0(rep(x = "A",
#                                                            times = attr(regexpr(pattern = "A(-+)$",
#                                                                                 text = tplpHap$hap[x],
#                                                                                 perl = T),
#                                                                         'capture.length')[1]),
#                                                        collapse = "")),
#                            x = tplpHap$hap[x],
#                            perl = T)
#    }
#  }
#}

# As an allele-specific primer on the right binds only Ws-4 (B) alleles,
# impute missing haplotypes at the right-hand side (end) of alignments
# that have a Ws-4 (B) allele at a marker on their left
# (e.g., for "-BAAAAAAAAAB----", only the right-hand "----" and
#  not the left-hand "-" would be imputed as "B")
# For Ws-4 (B) alleles
# right-hand side (end) of alignments
while( sum(grepl(pattern = "B(-+)$",
                 x = tplpHap$hap,
                 perl = T)) > 0 ) {
  for(x in 1:length(tplpHap$hap)) {
    if( grepl(pattern = "B(-+)$",
              x = tplpHap$hap[x],
              perl = T) ) {
      tplpHap$hap[x] <- sub(pattern = "B(-+)$",
                            replacement = paste0("B",
                                                 paste0(rep(x = "B",
                                                            times = attr(regexpr(pattern = "B(-+)$",
                                                                                 text = tplpHap$hap[x],
                                                                                 perl = T),
                                                                         'capture.length')[1]),
                                                        collapse = "")),
                            x = tplpHap$hap[x],
                            perl = T)
    }
  }
}
## (to be used for Ws-4 (B) alleles ONLY where a Ws-4-specific
##  primer binds the left-hand side of the amplicon)
## left-hand side (beginning) of alignments
#while( sum(grepl(pattern = "^(-+)B",
#                 x = tplpHap$hap,
#                 perl = T)) > 0 ) {
#  for(x in 1:length(tplpHap$hap)) {
#    if( grepl(pattern = "^(-+)B",
#              x = tplpHap$hap[x],
#              perl = T) ) {
#      tplpHap$hap[x] <- sub(pattern = "^(-+)B",
#                            replacement = paste0(paste0(rep(x = "B",
#                                                            times = attr(regexpr(pattern = "^(-+)B",
#                                                                                 text = tplpHap$hap[x],
#                                                                                 perl = T),
#                                                                         'capture.length')[1]),
#                                                        collapse = ""),
#                                                 "B"),
#                            x = tplpHap$hap[x],
#                            perl = T)
#    }
#  }
#}

# Order by (imputed) haplotypes
tplpHap_sort <- tplpHap[sort.int(tplpHap$hap,
                                 decreasing = T,
                                 index.return=T)$ix,]
# Group by (imputed) haplotypes
tplpHap_group_n <- tplpHap %>%
  group_by(hap) %>%
  summarize(n())

# Extract the top 1% of haplotypes in terms
# of frequency of occurrence
tplpHap_group_n_quant <- tplpHap_group_n %>%
  filter(`n()` > quantile(`n()`, 0.99))

tplpHap_group_n_v1 <- tplpHap_group_n
tplpHap_group_n_quant_v1 <- tplpHap_group_n_quant

# For those haplotypes in the top 1% which contain "-",
# impute "-" as "A" or "B" proportional to the observed
# frequency of occurrence of the two otherwise matching
# haplotypes
# (e.g., "A-BBBBBBBBBBBBBB" occurs 130 times,
#        "AABBBBBBBBBBBBBB" occurs 550 times,   
#        "ABBBBBBBBBBBBBBB" occurs 2332 times;
#  550 + round( 130 * ( 550 / (550+2332) ) ) = 575 "AABBBBBBBBBBBBBB" occurrences after imputation
#  2332 + round( 130 * ( 2332 / (550+2332) ) ) = 2437 "ABBBBBBBBBBBBBBB" occurrences after imputation
while( sum(grepl(pattern = "-",
                 x = tplpHap_group_n_quant$hap,
                 perl = T)) > 0 ) {
  for(x in 1:length(tplpHap_group_n_quant$hap)) {
    if( grepl(pattern = "-",
              x = tplpHap_group_n_quant$hap[x],
              perl = T) ) {
      impA <- sub(pattern = "-",
                  replacement = "A",
                  x = tplpHap_group_n_quant$hap[x],
                  perl = T)
      impB <- sub(pattern = "-",
                  replacement = "B",
                  x = tplpHap_group_n_quant$hap[x],
                  perl = T)
      hapNfreq <- tplpHap_group_n_quant$`n()`[x]
      hapAfreq <- tplpHap_group_n$`n()`[tplpHap_group_n$hap %in% impA]
      hapBfreq <- tplpHap_group_n$`n()`[tplpHap_group_n$hap %in% impB]
      # If impA or impB are not present in tplpHap_group_n$hap (unlikely),
      # redefine zero-length integer vector ( integer(0) ) with 0
      if( !length(hapAfreq) ) { hapAfreq <- 0 }
      if( !length(hapBfreq) ) { hapBfreq <- 0 }
      if( hapAfreq + hapBfreq >= 1 ) {
        hapNfreqA <- round( hapNfreq * ( hapAfreq / ( hapAfreq + hapBfreq ) ) )
        hapNfreqB <- round( hapNfreq * ( hapBfreq / ( hapAfreq + hapBfreq ) ) )
        imphapAfreq <- hapAfreq + hapNfreqA
        print(paste0("Augmented haplotype frequency for ",
                     impA, " = ", imphapAfreq))
        imphapBfreq <- hapBfreq + hapNfreqB
        print(paste0("Augmented haplotype frequency for ",
                     impB, " = ", imphapBfreq))
        # Sanity check
        if( ( imphapAfreq + imphapBfreq ) != ( hapNfreq + hapAfreq + hapBfreq ) ) {
          stop(paste0("Augmented haplotype frequencies for ",
                      tplpHap_group_n_quant$hap[x],
                      " do not add up to summed frequencies for ",
                      tplpHap_group_n_quant$hap[x], " , ",
                      impA, " , and ",
                      impB, " !"))
        }
      } else {
      stop(paste0("Complete versions of haplotype ",
                  tplpHap_group_n_quant$hap[x],
                  " are not present in the alignment dataset!"))
      }
      # Replace haplotypes in tplpHap$hap matching tplpHap_group_n_quant$hap[x]
      # with imputed haplotypes proportional to the observed
      # frequency of occurrence of the two otherwise matching haplotypes
      # which have "A" or "B" at the marker with "-" in tplpHap_group_n_quant$hap[x]
      tplpHap[tplpHap$hap == tplpHap_group_n_quant$hap[x],]$hap <- c(rep(x = impA,
                                                                         times = hapNfreqA),
                                                                     rep(x = impB,
                                                                         times = hapNfreqB))
    }
  }
  # Group by (imputed) haplotypes
  tplpHap_group_n <- tplpHap %>%
    group_by(hap) %>%
    summarize(n())
  
  # Extract the top 1% of haplotypes in terms
  # of frequency of occurrence
  tplpHap_group_n_quant <- tplpHap_group_n %>%
    filter(`n()` > quantile(`n()`, 0.99))
}

# Convert haplotype frequencies into proportions
tplpHap_group_n_quant_prop <- tplpHap_group_n_quant$`n()` /
                              (sum(tplpHap_group_n_quant$`n()`))

# Get inter-marker distances and midpoints
#### NOTE CHANGE WIDTH DEFINED BY COLUMN NUMBER
midpoints <- NULL
widths <- NULL
for(x in 1:(length(as.integer(colnames(tplpHap)[1:(dim(tplpHap)[2]-1)]))-1)) {
  midpointx <- as.integer(colnames(tplpHap)[x]) +
    round( ( as.integer(colnames(tplpHap)[x+1]) -
             as.integer(colnames(tplpHap)[x]) ) / 2 )
  midpoints <- c(midpoints, midpointx)
  widthx <- ( as.integer(colnames(tplpHap)[x+1]) -
              as.integer(colnames(tplpHap)[x]) ) + 1
  widths <- c(widths, widthx)
}
widths <- as.vector(sapply(seq_along(widths), function(x) rep(widths[x], times = 2)))

# Create a matrix of inter-marker recombination intervals, in which
# 1 denotes an "A" to "B" or a "B" to "A" transition, and
# 0 denotes no transition in parental allele from one marker to the next
# Two "1"s or two "0"s are appended to represent two-marker interval
tplpHap_quant <- tplpHap[tplpHap$hap %in% tplpHap_group_n_quant$hap,]
hapRecDF <- data.frame()
for(x in 1:(dim(tplpHap_quant)[1])) {
  hapRec <- NULL
  for(i in 1:(length(unlist(strsplit(tplpHap_quant$hap[x], split = "")))-1)) {
    if( paste0( unlist(strsplit(tplpHap_quant$hap[x], split = ""))[i],
                unlist(strsplit(tplpHap_quant$hap[x], split = ""))[i+1] )
        %in% c("AB", "BA") ) {
      hapRec <- c(hapRec, 1, 1)
    } else {
      hapRec <- c(hapRec, 0, 0)
    }
  }
  hapRecDF <- rbind(hapRecDF, hapRec)
}
colnames(hapRecDF) <- sort(c(alleles$position[2:(length(alleles$position)-2)],
                             alleles$position[3:(length(alleles$position)-1)]-1))

# From the above complete recombination matrix:
# extract alignments containing only crossovers
hapRecDF_COs <- hapRecDF[rowSums(hapRecDF) == 2,]
# extract alignments containing both crossovers and non-crossovers
hapRecDF_NCOs <- hapRecDF[rowSums(hapRecDF) == 6,]

# For each recombination matrix (complete and subsetted),
# calculate cM/Mb in each marker interval
cMMb <- data.frame(window = as.integer(colnames(hapRecDF)),
                   All = as.vector( ( (colSums(hapRecDF)/dim(hapRecDF)[1]) * 100 ) /
                                     (widths/1e6) ),
                   COs = as.vector( ( (colSums(hapRecDF_COs)/dim(hapRecDF)[1]) * 100 ) /
                                     (widths/1e6) ),
                   NCOs = as.vector( ( (colSums(hapRecDF_NCOs)/dim(hapRecDF)[1]) * 100 ) /
                                     (widths/1e6) )
                  )
cMMb_tidy <- gather(data = cMMb,
                    key = aln,
                    value = cMMb,
                    -window)

cM <- data.frame(window = as.integer(colnames(hapRecDF)),
                 All = as.vector( (colSums(hapRecDF)/dim(hapRecDF)[1]) * 100 ),
                 COs = as.vector( (colSums(hapRecDF_COs)/dim(hapRecDF)[1]) * 100 ),
                 NCOs = as.vector( (colSums(hapRecDF_NCOs)/dim(hapRecDF)[1]) * 100 ))
cM_tidy <- gather(data = cM,
                  key = aln,
                  value = cM,
                  -window)

# Complete amplicon extends from 634089 (20 nt upstream of 634109)
# to 639952 (18 nt downstream of 639934)

# Define legend labels
alnNames <- c(bquote("All (" *
                     .(prettyNum(dim(hapRecDF)[1],
                                 big.mark = ",", trim = T)) *
                     ")"),
              bquote("COs (" *
                     .(prettyNum(dim(hapRecDF_COs)[1],
                                 big.mark = ",", trim = T)) *
                     ")"),
              bquote("COs & NCOs (" *
                     .(prettyNum(dim(hapRecDF_NCOs)[1],
                                 big.mark = ",", trim = T)) *
                     ")"))
alnColours <- c("navy", "orangered", "green")
makeTransparent <- function(thisColour, alpha = 180)
{
  newColour <- col2rgb(thisColour)
  apply(newColour, 2, function(x) {
    rgb(red = x[1], green = x[2], blue = x[3],
        alpha = alpha, maxColorValue = 300)
  })
}
alnColours <- makeTransparent(alnColours)
legendPos <- as.numeric(unlist(strsplit("0.01,0.96",
                                        split = ",")))
legendLabs <- lapply(seq_along(alnNames), function(x) {
  grobTree(textGrob(bquote(.(alnNames[x])),
                    x = legendPos[1], y = legendPos[2]-((x-1)*0.06), just = "left",
                    gp = gpar(col = alnColours[x], fontsize = 18)))
})  

# Plot recombination rates for group of alignments
# (all, COs only, both COs and NCOs)
plotDir <- "/home/ajt200/analysis/nanopore/pollen_typing/"
ggObj_cMMb <- ggplot(data = cMMb_tidy,
                     mapping = aes(x = window,
                                   y = cMMb,
                                   group = aln)) +
  geom_line(data = cMMb_tidy,
            mapping = aes(colour = aln),
            size = 1) +
  scale_colour_manual(values = alnColours) +
  scale_x_continuous(breaks = c(alleles$position),
                     labels = c(as.character(alleles$position))) +
  scale_y_continuous(labels = function(x) sprintf("%4.0f", as.numeric(x))) +
  geom_vline(xintercept = c(alleles$position),
             linetype = "dashed",
             size = 0.5) +
  labs(x = bquote(italic("3a") ~ "marker"),
       y = "cM/Mb") +
  annotation_custom(legendLabs[[1]]) +
  annotation_custom(legendLabs[[2]]) +
  annotation_custom(legendLabs[[3]]) +
  theme_bw() +
  theme(
        axis.ticks = element_line(size = 1.0, colour = "black"),
        axis.ticks.length = unit(0.25, "cm"),
        axis.text.x = element_text(size = 18, colour = "black", family = "Luxi Mono", angle = 90, vjust = 0.5),
        axis.text.y = element_text(size = 18, colour = "black", family = "Luxi Mono"),
        axis.title = element_text(size = 30, colour = "black"),
        legend.position = "none",
        panel.grid = element_blank(),
        panel.border = element_rect(size = 3.5, colour = "black"),
        panel.background = element_blank(),
        plot.margin = unit(c(0.3,1.2,0.0,0.3), "cm"),
        plot.title = element_text(hjust = 0.5, size = 30)) +
  ggtitle(bquote(.(sample) ~ "ONT (" * italic("n") ~ "=" ~
                 .(prettyNum(dim(hapRecDF)[1],
                             big.mark = ",", trim = T)) *
                 ")"))

ggObj_cM <- ggplot(data = cM_tidy,
                   mapping = aes(x = window,
                                 y = cM,
                                 group = aln)) +
  geom_line(data = cM_tidy,
            mapping = aes(colour = aln),
            size = 1) +
  scale_colour_manual(values = alnColours) +
  scale_x_continuous(breaks = c(alleles$position),
                     labels = c(as.character(alleles$position))) +
  scale_y_continuous(labels = function(x) sprintf("%1.2f", as.numeric(x))) +
  geom_vline(xintercept = c(alleles$position),
             linetype = "dashed",
             size = 0.5) +
  labs(x = bquote(italic("3a") ~ "marker"),
       y = "cM") +
  annotation_custom(legendLabs[[1]]) +
  annotation_custom(legendLabs[[2]]) +
  annotation_custom(legendLabs[[3]]) +
  theme_bw() +
  theme(
        axis.ticks = element_line(size = 1.0, colour = "black"),
        axis.ticks.length = unit(0.25, "cm"),
        axis.text.x = element_text(size = 18, colour = "black", family = "Luxi Mono", angle = 90, vjust = 0.5),
        axis.text.y = element_text(size = 18, colour = "black", family = "Luxi Mono"),
        axis.title = element_text(size = 30, colour = "black"),
        legend.position = "none",
        panel.grid = element_blank(),
        panel.border = element_rect(size = 3.5, colour = "black"),
        panel.background = element_blank(),
        plot.margin = unit(c(0.3,1.2,0.0,0.3), "cm"),
        plot.title = element_text(hjust = 0.5, size = 30)) +
  ggtitle(bquote(.(sample) ~ "ONT (" * italic("n") ~ "=" ~
                 .(prettyNum(dim(hapRecDF)[1],
                             big.mark = ",", trim = T)) *
                 ")"))
ggObjGA_combined <- grid.arrange(ggObj_cMMb,
                                 ggObj_cM,
                                 nrow = 2, as.table = F)
                                                    
ggsave(paste0(plotDir, sample, "_ONT_cMMb_cM_v101219.pdf"),
       plot = ggObjGA_combined,
       height = 6.5*2, width = 20, limitsize = F)
