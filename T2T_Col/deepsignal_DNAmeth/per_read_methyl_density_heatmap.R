#!/applications/R/R-4.0.0/bin/Rscript

# Usage:
# /applications/R/R-4.0.0/bin/Rscript per_read_methyl_density_heatmap.R WT_deepsignalDNAmeth_95_30kb T2T_Col 100000 CpG

args <- commandArgs(trailingOnly = T)
sampleName <- args[1]
refbase <- args[2]
genomeBinSize <- as.integer(args[3])
context <- args[4]

if(floor(log10(genomeBinSize)) + 1 < 4) {
  genomeBinName <- paste0(genomeBinSize, "bp")
} else if(floor(log10(genomeBinSize)) + 1 >= 4 &
          floor(log10(genomeBinSize)) + 1 <= 6) {
  genomeBinName <- paste0(genomeBinSize/1e3, "kb")
} else if(floor(log10(genomeBinSize)) + 1 >= 7) {
  genomeBinName <- paste0(genomeBinSize/1e6, "Mb")
}

options(stringsAsFactors = F)
library(segmentSeq)
library(ComplexHeatmap)

# Genomic definitions
fai <- read.table(paste0("/home/ajt200/analysis/nanopore/T2T_Col/", refbase, ".fa.fai"), header = F)
if(!grepl("Chr", fai[,1][1])) {
  chrs <- paste0("Chr", fai[,1][1:5])
} else {
  chrs <- fai[,1][1:5]
}
chrLens <- fai[,2][1:5]

# Make chromosomal coordinates cumulative
# such that the first coordinate of Chr2 is
# equal to the last coordinate of Chr1 + 1
sumchr <- cumsum(c(0, chrLens))
print(sumchr)

# Load table of per-read methylation proportions, in which
# each coordinate corresponds to the midpoint between the
# first and last cytosine position with methylation info in the read
tab <- read.table(paste0("/home/ajt200/analysis/nanopore/T2T_Col/deepsignal_DNAmeth/",
                         "WT_deepsignalDNAmeth_95_30kb_MappedOn_T2T_Col_",
                         context, "_per_read_midpoint.tsv"),
                  header = T)
colnames(tab) <- c("chr", "midpoint", "per_read_mProp")
tab[,2] <- round(tab[,2])
tab <- tab[with(tab, order(chr, midpoint, decreasing = FALSE)),]

# For each genomeBinSize-bp adjacent window, calculate the mean of the genomeBinSize
# per-base DNA methylation proportions within that window
print(genomeBinName)
cumMethDat <- NULL
for(i in seq_along(chrs)) {
  # Define adjacent windows
  winSeq <- seq(from = 1, to = chrLens[i], by = genomeBinSize)
  winCum <- winSeq + sumchr[i]
  winIR <- IRanges(start = winSeq,
                   width = genomeBinSize)
  winIR <- winIR[-length(winIR)]
  winIR <- append(winIR,
                  IRanges(start = winSeq[length(winSeq)],
                          end = chrLens[i]))
  winGR <- GRanges(seqnames = chrs[i],
                   ranges = winIR,
                   strand = "*")
  print(winGR)

  # Define per-read midpoint coordinates as GRanges objects
  # and get corresponding DNA methylation proportions that overlap genomic windows
  chr_tab <- tab[tab[,1] == chrs[i],]
  chr_tab_GR <- GRanges(seqnames = chrs[i],
                        ranges = IRanges(start = chr_tab[,2],
                                         width = 1),
                        strand = "*",
                        per_read_mProp = chr_tab[,3])

  # Identify overlapping windows and midpoint coordinates
  fOverlaps <- findOverlaps(query = winGR,
                            subject = chr_tab_GR,
                            type = "any",
                            select = "all",
                            ignore.strand = TRUE)
  # Convert fOverlaps into list object equivalent to that
  # generated by segmentSeq::getOverlaps(), in which each
  # list element corresponds to a genomic window of
  # sequentially numbered read midpoint coordinates
  fOverlapsList <- mclapply(seq_along(unique(queryHits(fOverlaps))),
                            function(x) {
                              subjectHits(fOverlaps[queryHits(fOverlaps) == x])
                            }, mc.cores = detectCores(), mc.preschedule = TRUE)
  # Get per-read methylation proportion values overlapping each window
  win_tab <- sapply(fOverlapsList, function(x) {
               chr_tab[,3][x]
             })

  win_tab_overlaps <- getOverlaps(coordinates = winGR,
                                  segments = chrCG_GR,
                                  overlapType = "overlapping",
                                  whichOverlaps = TRUE,
                                  ignoreStrand = TRUE)
  CGwinVals <- sapply(CGoverlaps, function(x) mean(as.numeric(chrCG[,3][x])))





